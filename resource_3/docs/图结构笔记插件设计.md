# Obsidian 纯图结构笔记插件设计

## 背景

Obsidian 的双链功能比较鸡肋——它只是单纯的"引用"，没有**边的语义**。`[[A]]` 只表示"引用了A"，但不知道是"支持A"、"反驳A"、"是A的实例"还是"依赖A"。

目标：实现一个纯图结构的笔记管理系统，其中：
- **节点** = md文件
- **边** = 有类型、有样式的关系

---

## 方案探索

### 方案1：Frontmatter 定义边（复杂版）

```yaml
---
relations:
  - target: "热力学第二定律"
    type: "derived_from"
    note: "熵是第二定律的核心概念"
  - target: "信息论"
    type: "borrowed_by"
    weight: 0.9
---
```

**优点**：结构化、边可以有多个属性
**缺点**：写起来繁琐

### 方案2：属性名即边类型（简化版）✅ 已选定

```yaml
---
supports: "[[目标A]]"
refutes: "[[目标B]]"
derived_from:
  - "[[目标C]]"
  - "[[目标D]]"
---
```

**优点**：简洁、与现有插件兼容
**缺点**：边的额外属性需要另外存储

---

## 参考插件分析

### 1. Graph-Link-Types

**核心思路**：
- 使用 Dataview API 读取 frontmatter
- **边的类型 = frontmatter 属性名**
- 用 PixiJS 在 Graph View 上叠加渲染

**关键代码** (`linkManager.ts`):
```typescript
// 遍历源文件的所有frontmatter属性
for (const [key, value] of Object.entries(sourcePage)) {
    // 如果属性值是指向目标的链接，属性名就是边类型
    if (value.path === targetId) {
        return key;  // 返回属性名作为边类型
    }
}
```

**代码结构**：
```
Graph-Link-Types/
├── src/
│   ├── main.ts          # 插件入口，监听layout-change
│   ├── linkManager.ts   # 核心逻辑，管理边的渲染
│   └── types.ts         # 类型定义
```

**优点**：代码只有3个文件，非常简洁
**缺点**：依赖 Dataview，边只有类型没有其他属性

### 2. Extended Graph

**核心思路**：与 Graph-Link-Types 相同，但功能更丰富

**关键代码** (`helpers/vault.ts`):
```typescript
// 从 frontmatterLinks 获取边类型
for (const linkCache of frontmatterLinks) {
    const linkType = linkCache.key.split('.')[0];  // 属性名作为类型
}
```

**功能**：
- 链接类型着色和标签
- 曲线链接
- 节点图标/图片
- 按标签/文件夹/属性分组着色
- 图层管理
- 过滤器

**缺点**：代码极其复杂（50+文件），难以维护

---

## 最终方案：增强版 Graph-Link-Types

### 核心设计

1. **边的定义**：在笔记的 frontmatter 中，属性名 = 边类型
2. **边的样式**：在 `ob_relation/` 目录中，每个边类型一个配置文件

### 目录结构

```
root/
├── ob_relation/                    # 边类型样式配置（全局）
│   ├── supports.md              # color: #4CAF50, style: solid
│   ├── refutes.md               # color: #F44336, style: dashed
│   ├── derived_from.md          # color: #2196F3, style: solid
│   ├── equivalent_to.md         # color: #9C27B0, style: dotted
│   └── instance_of.md           # color: #FF9800, style: solid
│
├── demo/                        # 笔记示例
│   ├── 熵.md
│   ├── 热力学第二定律.md
│   ├── 信息论.md
│   ├── 信息熵.md
│   └── 时间之箭.md
│
└── README.md
```

### 边的定义（笔记 frontmatter）

```yaml
---
supports: "[[热力学第二定律]]"
equivalent_to: "[[信息熵]]"
---

# 熵

熵是描述系统无序程度的物理量。
```

### 边的样式配置（ob_relation/*.md）

```yaml
---
$color: "#4CAF50"        # 边颜色 (hex)
$style: solid            # solid | dashed | dotted
$width: 2                # 线宽
$arrow: true             # 是否显示箭头
$direction: outgoing     # outgoing | incoming | bidirectional
$inverse: "supported_by" # 反向关系类型名
$label: "支持"           # 在图上显示的标签
$description: "表示A支持/证实B的观点"
---

# supports（支持）

当节点A的内容支持、证实或强化节点B时使用此关系。
```

### 笔记中使用关系的两种方式

详见：[笔记使用指南](./笔记使用指南.md)

#### 方式1：Frontmatter（推荐）
```yaml
---
supports: "[[热力学第二定律]]"
derived_from:
  - "[[玻尔兹曼熵]]"
  - "[[信息论]]"
---
```

#### 方式2：内联关系（Dataview）
```markdown
这个观点 [supports:: [[热力学第二定律]]]，但 [refutes:: [[永动机]]]。
```

**建议**：核心关系用 Frontmatter，上下文注释用内联。

---

## 插件架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                        插件架构                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. RelationStyleManager                                    │
│     ├── 监听 ob_relation/ 目录变化                              │
│     ├── 解析每个 .md 的 frontmatter                          │
│     └── 缓存: Map<边类型名, {color, style, width, ...}>      │
│                                                             │
│  2. LinkTypeResolver (复用 Graph-Link-Types 逻辑)            │
│     ├── 遍历笔记 frontmatter                                 │
│     └── 属性名 = 边类型，属性值 = 目标节点                    │
│                                                             │
│  3. GraphRenderer (基于 PixiJS)                             │
│     ├── 根据边类型查询样式                                   │
│     ├── 应用 color/style/width                              │
│     └── 渲染到 Graph View                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 核心流程

1. **启动时**：扫描 `ob_relation/` 目录，读取所有边类型的样式配置
2. **文件名匹配**：`ob_relation/supports.md` → 边类型 `supports`
3. **Graph渲染时**：
   - 遍历所有链接
   - 获取边类型（frontmatter 属性名）
   - 查询对应样式
   - 用 PixiJS 渲染

---

## 边的方向设计

### 方案选择：在 ob_relation 配置中定义方向语义 ✅

边的方向通过 `direction` 和 `inverse` 字段在配置文件中定义。

### 配置示例

```yaml
# ob_relation/supports.md
---
color: "#4CAF50"
style: solid
width: 2
arrow: true
direction: outgoing        # outgoing | incoming | bidirectional
inverse: "supported_by"    # 反向关系类型名
label: 支持
---
```

```yaml
# ob_relation/supported_by.md
---
color: "#4CAF50"
style: solid
width: 2
arrow: true
direction: incoming
inverse: "supports"
label: 被支持
---
```

### 使用方式

```yaml
# 在 A.md 中
---
supports: "[[B]]"           # A → B（A支持B）
supported_by: "[[C]]"       # C → A（A被C支持）
---
```

### 方向字段说明

| 字段 | 值 | 含义 |
|------|------|------|
| `direction` | `outgoing` | 当前文件 → 目标文件 |
| `direction` | `incoming` | 目标文件 → 当前文件 |
| `direction` | `bidirectional` | 双向关系 |
| `inverse` | 边类型名 | 该关系的反向关系类型 |

### 成对关系示例

| 正向关系 | 反向关系 | 说明 |
|----------|----------|------|
| `supports` | `supported_by` | 支持 ↔ 被支持 |
| `derived_from` | `derives` | 派生自 ↔ 派生出 |
| `instance_of` | `has_instance` | 是实例 ↔ 有实例 |
| `refutes` | `refuted_by` | 反驳 ↔ 被反驳 |

---

## 预定义边类型

### 基础关系

| 类型 | 反向类型 | 颜色 | 样式 | 含义 |
|------|----------|------|------|------|
| `supports` | `supported_by` | #4CAF50 (绿) | solid | A支持/证实B |
| `refutes` | `refuted_by` | #F44336 (红) | dashed | A反驳/否定B |
| `derived_from` | `derives` | #2196F3 (蓝) | solid | A从B派生 |
| `equivalent_to` | - | #9C27B0 (紫) | dotted | A与B等价（双向） |
| `instance_of` | `has_instance` | #FF9800 (橙) | solid | A是B的实例 |

### 因果与依赖

| 类型 | 反向类型 | 颜色 | 样式 | 含义 |
|------|----------|------|------|------|
| `causes` | `caused_by` | #FF5722 (深橙) | solid | A导致B |
| `depends_on` | `depended_by` | #9E9E9E (灰) | solid | A依赖于B |

### 结构关系

| 类型 | 反向类型 | 颜色 | 样式 | 含义 |
|------|----------|------|------|------|
| `part_of` | `has_part` | #795548 (棕) | solid | A是B的一部分 |
| `extends` | `extended_by` | #009688 (青) | solid | A扩展B |

### 继承与分类

| 类型 | 反向类型 | 颜色 | 样式 | 含义 |
|------|----------|------|------|------|
| `inherits_from` | `inherited_by` | #FF6F00 (橙红) | solid | A继承B（OOP继承） |
| `subclass_of` | `has_subclass` | #FF6F00 (橙红) | solid | A是B的子类（概念层级） |

### 应用与实现

| 类型 | 反向类型 | 颜色 | 样式 | 含义 |
|------|----------|------|------|------|
| `applies_to` | `applied_by` | #3F51B5 (靛) | solid | A应用于B |

### 对立与相似

| 类型 | 反向类型 | 颜色 | 样式 | 含义 |
|------|----------|------|------|------|
| `contradicts` | `contradicted_by` | #E91E63 (粉红) | dashed | A与B矛盾 |
| `similar_to` | - | #00BCD4 (青色) | dotted | A与B相似（双向） |
| `related_to` | - | #607D8B (蓝灰) | dotted | A与B相关（双向） |

---

## 后续开发计划

1. 基于 Graph-Link-Types 代码结构改造
2. 添加 RelationStyleManager 模块
3. 实现边样式的动态加载
4. 支持 dashed/dotted 线条样式
5. 可选：添加边的权重显示
